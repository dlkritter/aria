# SPDX-License-Identifier: Apache-2.0
import aria.range.int_extension;

struct Timer {
    type func new(f) {
        return alloc(This) {
            .fn = f,
            .samples = []
        };
    }

    func run(n=1) {
        val start = now();
        for _ in 0.to(n) {
            this.fn();
        }
        val end = now();
        val duration = (end - start)/1000.0;
        this.samples.append(duration);
        return duration;
    }

    func average() {
        if this.samples.len() == 0 {
            return 0.0;
        }
        return this.samples.sum() / this.samples.len();
    }

    func percentile(p) {
        val n = this.samples.len();
        if n == 0 {
            return 0.0;
        }

        val s = this.samples;
        s.quicksort();

        val idxf = (p / 100.0) * (n - 1);
        val idx = idxf.int();
        return s[idx];
    }

    func p50() {
        return this.percentile(50.0);
    }

    func p99() {
        return this.percentile(99.0);
    }

    func p999() {
        return this.percentile(99.9);
    }

    func max() {
        return this.samples.max();
    }

    func min() {
        return this.samples.min();
    }
}

struct BenchmarkArguments {
    type func new() {
        val verbose = false;
        val count = 100;

        val args = cmdline_arguments();
        val i = 0;
        while i < args.len() {
            if args[i] == "--verbose" {
                verbose = true;
            } elsif args[i] == "--count" && i + 1 < args.len() {
                match Int.parse(args[i+1]) {
                    case Ok(x) => {
                        count = x;
                    },
                    case Err(e) => {
                        println("Invalid count argument: {0}".format(e));
                    }
                }
                i += 1;
            }

            i += 1;
        }

        return Box(){.count, .verbose};
    }
}

# include this mixin and provide a func test() to create a microbenchmark
mixin Microbenchmark {
    type func new(name) = alloc(This) { .name };

    # override this if you need to prepare data before running the benchmark
    func prepare() {}

    # override this if you need to clean up after running the benchmark
    func teardown() {}

    func _iter(collect, verbose) {
        this.prepare();
        if collect {
            val duration = this.timer.run();
            if verbose {
                println("{1} duration: {0:.3}s".format(duration, this.name));
            }
        } else {
            this.test();
        }
        this.teardown();
    }

    func run(n=Maybe::None) {
        val args = BenchmarkArguments.new();
        val count = n ?? args.count;
        assert hasattr(this, "test");
        if !hasattr(this, "timer") {
            this.timer = Timer.new(this.test);
        }

        count += 10;
        val ten = 10;

        # and now do the real testing
        for _ in 0.to(count) {
            this._iter(ten == 0, ten == 0 && args.verbose);
            if ten > 0 {
                ten -= 1;
            }
        }

        println("{0} min: {1:.3}s p50: {2:.3}s p99: {3:.3}s p999: {4:.3}s max: {5:.3}s".format(
            this.name,
            this.timer.min()??,
            this.timer.p50(),
            this.timer.p99(),
            this.timer.p999(),
            this.timer.max()??
        ));
    }
}
