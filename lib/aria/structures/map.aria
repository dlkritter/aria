# SPDX-License-Identifier: Apache-2.0
import Iterator,Iterable from aria.iterator.mixin;

struct Map {
    type val DEFAULT_CAPACITY = 128;

    struct Entry {
        type func new(key, value) = alloc(This) {.key, .value};
    }

    func calc_hash(k) {
        val h = k.hash();
        val n = this.capacity;
        return ((h % n) + n) % n;
    }

    type func new() {
        return Map.new_with_capacity(Map.DEFAULT_CAPACITY);
    }

    type func new_with_capacity(capacity: Int) {
        if capacity <= 0 {
            capacity = Map.DEFAULT_CAPACITY;
        }

        return alloc(This) {
            .buckets = List.from_function(|_| => [], capacity),
            .count = 0,
            .capacity,
            .key_list = []
        };
    }

    type func frequency_map(iter) {
        val this = This.new();
        for item in iter {
            val count = this.get(item).unwrap_or(0);
            this.set(item, count + 1);
        }
        return this;
    }

    func keys() {
        val remaining = this.len();
        val ret = [];
        val buckets_len = this.buckets.len();
        for bucket in this.buckets {
            for entry in bucket {
                if entry isa Map.Entry {
                    ret.append(entry.key);
                    remaining -= 1;
                    if remaining == 0 {
                        return ret;
                    }
                }
            }
        }

        assert remaining == 0;
        return ret;
    }

    func prettyprint() {
        val first = true;
        val ret = "";
        val count = this.len();
        for bucket in this.buckets {
            for entry in bucket {
                if entry isa Map.Entry {
                    if first {
                        ret = "[{0}]->{1}".format(entry.key, entry.value);
                        first = false;
                    } else {
                        ret = ret + ", [{0}]->{1}".format(entry.key, entry.value);
                    }
                    count -= 1;
                    if count == 0 {
                        return "Map(" + ret + ")";
                    }
                }
            }
        }

        return "Map(" + ret + ")";
    }

    func set(k,v) {
        val h = this.calc_hash(k);
        val bucket = this.buckets[h];
        val bucket_len = bucket.len();
        val idx = 0;
        val need_append = true;
        val len_increase = true;
        while idx < bucket_len {
            match bucket[idx] {
                isa Map.Entry => {
                    if bucket[idx].key == k {
                        len_increase = false; # key overwrite does not increase len
                        bucket[idx].value = v;
                        need_append = false;
                        break;
                    }
                },
                isa Maybe => {
                    bucket[idx] = Map.Entry.new(k,v);
                    need_append = false;
                    break;
                }
            }
            idx = idx + 1;
        }
        if need_append {
            bucket.append(Map.Entry.new(k,v));
        }
        if len_increase {
            this.count += 1;
        }

        return len_increase;
    }

    func remove(k) {
        val h = this.calc_hash(k);
        val bucket = this.buckets[h];
        val bucket_len = bucket.len();
        val idx = 0;
        while idx < bucket_len {
            match bucket[idx] {
                isa Map.Entry => {
                    if bucket[idx].key == k {
                        assert this.count > 0;
                        this.count -= 1;
                        bucket[idx] = Maybe::None;
                        return true;
                    }
                }
            }
            idx = idx + 1;
        }

        return false;
    }

    func get(k) {
        val h = this.calc_hash(k);
        val bucket = this.buckets[h];
        val bucket_len = bucket.len();
        for entry in bucket {
            if (entry isa Map.Entry) && entry.key == k {
                return Maybe::Some(entry.value);
            }
        }
        return Maybe::None;
    }

    func contains(k) {
        return this.get(k).is_Some();
    }

    func len() {
        return this.count;
    }

    operator [](k) {
        return this.get(k).unwrap_Some();
    }

    operator []=(k,v) {
        return this.set(k,v);
    }

    struct MapIterator {
        type func new(m: Map) {
            return alloc(This){
                .buckets = m.buckets,
                .bucket_idx = 0,
                .entry_idx = 0,
            };
        }

        func next() {
            val buckets = this.buckets;
            val num_buckets = buckets.len();
            
            while this.bucket_idx < num_buckets {
                val bucket = buckets[this.bucket_idx];
                while this.entry_idx < bucket.len() {
                    val entry = bucket[this.entry_idx];
                    this.entry_idx += 1;
                    if entry isa Map.Entry {
                        return Maybe::Some(Box(){ .key = entry.key, .value = entry.value });
                    }
                }
                this.bucket_idx += 1;
                this.entry_idx = 0;
            }
            
            return Maybe::None;
        }

        include Iterator
    }

    func iterator() {
        return Map.MapIterator.new(this);
    }

    include Iterable
}
