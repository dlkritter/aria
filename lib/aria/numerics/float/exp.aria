# SPDX-License-Identifier: Apache-2.0
extension Float {
    func ln() {
        if this <= 0 {
            throw Float.DomainError.new("logarithm undefined for non-positive values");
        }

        val LN2 = 0.6931471805599453;
        val ε = 1.0e-15;
        val max_iterations = 10000;

        val x = this;
        val k = 0;
        val mant = x;

        while mant >= 2.0f {
            mant = mant / 2.0f;
            k = k + 1;
        }

        while mant < 1.0f {
            mant = mant * 2.0f;
            k = k - 1;
        }

        if mant == 1.0f {
            return k * LN2;
        }

        val y = (mant - 1.0f) / (mant + 1.0f);
        val y2 = y * y;

        val term = y;
        val sum = 0.0f;
        val n = 1;
        val iterations = 0;
        while iterations < max_iterations {
            sum = sum + term / n;
            term = term * y2;
            n = n + 2;
            iterations = iterations + 1;
            if (term.abs() / n) < ε {
                break;
            }
        }

        val ln_val = 2.0f * sum;
        return ln_val + k * LN2;
    }

    func exp() {
        val ε = 0.000000000001f;
        val max_iterations = 1000;

        if this == 0.0f {
            return 1.0f;
        }

        val reduced = this;
        val scale = 0;
        while reduced.abs() > 0.5f {
            reduced = reduced / 2.0f;
            scale = scale + 1;
        }

        val result = 1.0f;
        val term = 1.0f;
        val iterations = 0;
        while iterations < max_iterations {
            iterations = iterations + 1;
            term = term * reduced / iterations;
            if term.abs() < ε {
                break;
            }
            result = result + term;
        }

        val i = 0;
        while i < scale {
            result = result * result;
            i = i + 1;
        }

        return result;
    }

    func pow(exponent: Int|Float) {
        match exponent {
            == 0 => { return 1.0f; },
            == 1 => { return this; }
            isa Int => {
                exponent += 0.0f;
            }
        }

        if this < 0 && exponent % 1 != 0 {
            throw Float.DomainError.new("cannot calculate fractional power of negative integer");
        }

        val is_exponent_negative = exponent < 0;
        val abs_exponent = exponent.abs();

        val integer_part = abs_exponent.floor();
        val fractional_part = abs_exponent - integer_part;

        val result = 1.0f;
        val temp = this;

        val i = 0;
        while i < integer_part {
            result = result * temp;
            i = i + 1;
        }

        if fractional_part > 0 {
            result = result * this.sqrt().pow(fractional_part * 2);
        }

        if is_exponent_negative {
            result = 1.0f / result;
        }

        return result;
    }
}