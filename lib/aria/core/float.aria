# SPDX-License-Identifier: Apache-2.0
flag: no_std;

func char_to_int(c: String) {
    match c {
        == "0" => { return 0; },
        == "1" => { return 1; },
        == "2" => { return 2; },
        == "3" => { return 3; },
        == "4" => { return 4; },
        == "5" => { return 5; },
        == "6" => { return 6; },
        == "7" => { return 7; },
        == "8" => { return 8; },
        == "9" => { return 9; },
    } else {
        return Maybe::None;
    }
}

extension Float {
    type val pi = 3.14159265358979323846f;
    type val e =  2.71828182845904523536f;
    type val π = Float.pi;
    type val phi = 1.618033988749895f;
    type val φ = Float.phi;

    func abs() {
        return this >= 0 ? this : -this;
    }

    struct DomainError {
        type func new(msg: String) {
            return alloc(This) {
                .msg = msg
            };
        }

        instance func prettyprint() {
            return "floating-point domain error: {0}".format(this.msg);
        }
    }

    func sqrt() {
        match this {
            == 0 => { return 0.0f; },
            == 1 => { return 1.0f; },
            < 0 => { throw Float.DomainError.new("square root undefined for negative values"); },
        }

        val ε = 0.000000000001f;

        val guess = this / 2;

        val i = 0;
        val n = 1000;
        while i < n {
            i = i + 1;
            val next_guess = (guess + this / guess) / 2;
            if (next_guess - guess).abs() < ε {
                return next_guess;
            } else {
                guess = next_guess;
            }
        }

        return guess;
    }

    type func parse(s: String) {
        if s.len() == 0 || s == "-" || s == "." {
            return Result::Err("invalid float format");
        }
        
        val ret = 0.0f;
        val i = 0;
        val sign = 1;
        val decimal_found = false;
        val decimal_factor = 0.1f;

        val s: List = s.chars();

        if s[0] == "-" {
            i = 1;
            sign = -1;
        }

        while i < s.len() {
            val chr = s[i];
            if chr == "e" || chr == "E" {
                break;
            }
            if chr == "." {
                if decimal_found {
                    return Result::Err("duplicate decimal point");
                }
                decimal_found = true;
            } else {
                val digit = char_to_int(chr);
                if digit == Maybe::None {
                    return Result::Err("invalid float digit: " + chr);
                }
                if decimal_found {
                    ret = ret + digit * decimal_factor;
                    decimal_factor = decimal_factor / 10;
                } else {
                    ret = ret * 10 + digit;
                }
            }
            i += 1;
        }

        ret = sign * ret;

        if i < s.len() {
            i += 1;
            if i >= s.len() {
                return Result::Err("missing exponent");
            }

            val exp_sign = 1;
            if s[i] == "-" {
                exp_sign = -1;
                i += 1;
            } elsif s[i] == "+" {
                i += 1;
            }

            if i >= s.len() {
                return Result::Err("missing exponent digits");
            }

            val exp_value = 0;
            while i < s.len() {
                val digit = char_to_int(s[i]);
                if digit == Maybe::None {
                    return Result::Err("invalid float exponent digit: " + s[i]);
                }
                exp_value = exp_value * 10 + digit;
                i += 1;
            }

            val exp = exp_sign * exp_value;
            val factor = 1.0f;
            val j = 0;
            val limit = exp < 0 ? -exp : exp;
            while j < limit {
                factor = factor * 10;
                j += 1;
            }

            ret = exp < 0 ? ret / factor : ret * factor;
        }
        
        return Result::Ok(ret);
    }
}
